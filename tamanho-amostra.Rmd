---
title: "Tamanho mínimo de amostra"
author: "Arquimedes Macedo. Tiago Rodrigues"
output:
  html_document:
    df_print: paged
    theme: paper
    highlight: tango
    toc: true
    toc_float:
      collapsed: true
    code_folding: hide
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_file = file.path(dirname(inputFile), 'index.html')) })
---

<style>
.meme {
    display: block;
    max-width: 150px;
    max-height: 150px;
    width: auto;
    height: auto;
}
</style>


```{r echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(readxl)
library(knitr)
library(ggplot2)
library(ggridges)
library(reshape2)
library(gridExtra)
library(vtable)
library(purrr)

# Centering figures chunk output
knitr::opts_chunk$set(out.height = "\\textheight",  out.width = "\\textwidth",
                      out.extra = "keepaspectratio=true", fig.align = "center")
```

```{r echo=TRUE}
theme.base <- theme_minimal(base_size = 11) +
  theme(
    axis.text = element_text(size = 8),
    plot.title = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 10),
    panel.grid.major = element_line(colour = "grey90", linewidth = 0.5),
    panel.grid.minor = element_line(colour = adjustcolor("grey90", alpha.f = 0.5), linewidth = 0.25),
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    axis.line.x = element_line(colour = "grey"),
    axis.line.y = element_line(colour = "grey"),
  )

theme.no_legend <- theme(legend.position = "none")

theme.no_grid <-  theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()
)

theme.no_axis <- theme(
  axis.line.x = element_blank(),
  axis.line.y = element_blank()
)

```

## Objetivo

Estimar a quantidade média de leads diários, com 80% de confiança, por anunciante, de anúncios de vendas de imóveis na cidade de Florianópolis (SC).

*Lead*: é um contato de um cliente em potencial que demonstrou interesse em um produto ou serviço.

IC de 80% foi escolhido devido à falta de informações (descrita logo mais), e também por ser este o valor máximo recomendado pela ABNT para avaliações de imóveis (NBR 14653).

## Metodologia

Almeja-se, a partir de uma lista de anúncios, realizar uma busca diária de leads, usando uma amostra dos anúncios, e, a partir destes dados, estimar a quantidade média de leads.

No entanto, entende-se que há limitações nas informações disponíveis, como:

-   O número de leads por anúncio.
-   Tempo total que o anúncio ficou ativo.
-   A sazonalidade do mercado (oferta e demanda).
-   A eficácia do anúncio (qualidade do anúncio, preço, localização, etc).
-   A qualidade dos leads (interesse real ou apenas curiosidade).
-   A distribuição subjacente dos leads ao longo do tempo.

Desta forma como um estudo piloto, foram obtidos leads diários, entre Janeiro e Julho de 2024, de anúncios de um anunciante na cidade alvo.

### Análise exploratória

O banco de dados é composto por 3 colunas:

-   `id_registro`: identificador do lead.
-   `data_criado_em`: dia que o lead foi gerado.
-   `id_anuncio`: identificador do anúncio.

#### Amostra dos dados

```{r echo=TRUE}
df_leads <- read_excel("dataset/leads.xlsx", col_types = c("numeric", "date", "text"))
df_leads$data_criado_em <- as.Date(df_leads$data_criado_em)
kable(head(df_leads))
```

#### Leads diários

```{r echo=TRUE}
df_leads %>%
  group_by(data_criado_em) %>%
  summarise(leads = n()) %>%
  ggplot(aes(data_criado_em, leads)) +
  geom_line(color = "royalblue", linewidth = 0.5) +
  labs(title = "Leads diários",
       x = "Dia",
       y = "Leads") +
  scale_x_date(date_labels = "%b %d", date_breaks = "1 week") +
  theme.base + theme.no_legend +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  )

```

Notam-se picos em intervalos semi-regulares, o que pode indicar sazonalidade ou eventos específicos. Além disso, em Julho, houve uma alta variabilidade nos leads diários.

#### Leads por anúncio

Vamos analisar a média diária de leads por anúncio.

Para isso, dividimos o número total de leads pelo número de anúncios únicos para cada dia.

```{r class.source="bg-danger"}
df_leads_incorrect_mean <- df_leads %>%
  group_by(data_criado_em) %>%
  summarise(mean = n()/length(unique(id_anuncio)))

grid.arrange(
  df_leads_incorrect_mean %>%
    ggplot(aes(data_criado_em, mean)) +
    geom_line(color = "royalblue", linewidth = 0.5) +
    labs(title = "Média de leads por dia",
         x = "Dia",
         y = "Média de leads") +
    scale_x_date(date_labels = "%b %d", date_breaks = "1 week") +
    theme.base + theme.no_legend +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ),
  df_leads_incorrect_mean %>%
    ggplot(aes(mean)) +
    geom_histogram(bins = 30, color = "royalblue", fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "Média de leads",
         y = "") +
    theme.base + theme.no_legend,
  nrow = 2
)
```

<div>

<p style="text-align: center; font-size: 15px; font-weight: bold;">
Será que é só isso mesmo?
</p>

<p align="center" width="100%">
![](./images/loading-brain.jpg){.meme}
</p>

</div>

### Estimativa da média

Claro que não! A média diária de leads por anúncio é uma estimativa incorreta, pois não considera a quantidade de anúncios ativos em cada dia, e acaba gerando um viés. Para corrigir isso, vamos completar os dados com zeros para os dias sem leads.

Isto é, vamos pegar o primeiro e o último dia que o anúncio teve leads, e criar novos registros entre estas datas, para dias sem lead.

```{r}
df_leads_complete <- df_leads %>%
  group_by(id_anuncio, data_criado_em) %>%
  summarise(leads = n(), .groups = 'drop') %>%
  group_by(id_anuncio) %>%
  # Creates a list of dataframes by id
  tidyr::nest() %>%
  mutate(
    # Creates a sequence of dates by id
    date_seq = map(data, ~seq(min(.$data_criado_em), max(.$data_criado_em), by = "day")),
    # Completes the missing dates
    data = map2(
      data, date_seq,
      \(data_, seq_) {
        data_ %>%
          complete(data_criado_em = seq_, fill = list(leads = 0))
      }
    )
  ) %>%
  # Removes the auxiliary column
  select(-date_seq) %>%
  # Unnests the data
  unnest(data)

kable(head(df_leads_complete))
```

A partir desta correção, temos as seguintes médias diárias.

```{r}
df_leads_daily <- df_leads_complete %>%
  group_by(data_criado_em) %>%
  summarise(mean = mean(leads),
            total_leads = sum(leads),
            active_listings = n_distinct(id_anuncio))

grid.arrange(
  df_leads_daily %>%
    ggplot(aes(data_criado_em, mean)) +
    geom_line(color = "royalblue", linewidth = 0.5) +
    labs(title = "Média de leads por dia",
         x = "Dia",
         y = "Média de leads") +
    scale_x_date(date_labels = "%b %d", date_breaks = "1 week") +
    theme.base + theme.no_legend +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ),
  df_leads_daily %>%
    ggplot(aes(mean)) +
    geom_histogram(bins = 20, color = "royalblue", fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "Média de leads",
         y = "") +
    theme.base + theme.no_legend,
  nrow = 2
)
```

<div>

<p style="text-align: center; font-size: 15px; font-weight: bold;">
Mas não está totalmente correto...
</p>

<p align="center" width="100%">
![](./images/exercer-a-calma.jpg){.meme}
</p>

</div>

## Resultados

Lembrando que esta é uma aproximação e não corresponde totalmente ao que de fato aconteceu, para computar a verdadeira média, precisariamos da listagem de todos os anúncios ativos no dia.

Nota-se, também, que existem pontos extremos no início e no fim da série, isso pode ser explicado por anúncios que estavam ativos antes do início do período analisado ou que apareceram um pouco antes do fim.

Portanto vamos analisar apenas entre 01/02/2024 e 20/07/2024.

```{r}
df_leads_complete_filtered <- df_leads_complete %>%
  filter(between(data_criado_em, as.Date("2024-02-01"), as.Date("2024-07-20")))

df_leads_daily_filtered <- df_leads_complete_filtered %>%
  group_by(data_criado_em) %>%
  summarise(mean = mean(leads),
            total_leads = sum(leads),
            active_listings = n_distinct(id_anuncio))

grid.arrange(
  df_leads_daily_filtered %>%
    ggplot(aes(data_criado_em, mean)) +
    geom_line(color = "royalblue", linewidth = 0.5) +
    labs(title = "Média de leads por dia",
         x = "Dia",
         y = "Média de leads") +
    scale_x_date(date_labels = "%b %d", date_breaks = "1 week") +
    theme.base + theme.no_legend +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ),
  df_leads_daily_filtered %>%
    ggplot(aes(mean)) +
    coord_cartesian(xlim = c(-0.01, 0.4)) +
    geom_histogram(bins = 20, color = adjustcolor("royalblue", alpha.f = 0.3), fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "",
         y = "") +
    theme.base + theme.no_legend + theme.no_axis +
    theme(panel.grid.minor.y = element_blank()),
  df_leads_daily_filtered %>%
    ggplot(aes(mean)) +
    coord_cartesian(xlim = c(-0.02, 0.4)) +
    geom_boxplot(color = adjustcolor("royalblue", alpha.f = 0.8), fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "",
         y = "") +
    theme.base + theme.no_legend + theme.no_axis +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank()),
  nrow = 3,
  heights = c(3, 2, 1.5)
)
```

```{r}
leads_mean <- mean(df_leads_complete_filtered$leads)
leads_sd <- sd(df_leads_complete_filtered$leads)

sumtable(df_leads_daily_filtered, add.median = T, title = "Média de leads por dia")
```


```{r}
sumtable(df_leads_complete_filtered, add.median = T, title = "Registros corrigidos")
```

Assim, apesar dos pesares, temos uma média de `~`r round(leads_mean, 2)`` leads por dia, com um desvio padrão de `~`r round(leads_sd, 3)``.

### Tamanho da amostra

Calculamos que o tamanho da amostra, a partir da equação

$$
n' \ge \left(Z_{\alpha / 2} \frac{\sigma}{\text{e}}\right)^2
\\
n = n' \cdot \frac{N-n}{N-1}
$$

onde,
$Z_{\alpha / 2}$ é o valor crítico da distribuição normal,
$\text{e}$ é a margem de erro,
$\sigma$ é o desvio padrão,
$N$ é o tamanho da população,
$n'$ é o tamanho da amostra com amostra aleatória simples com reposição (AASc), e,
$n$ é o tamanho da amostra sem reposição.

```{r}
confidence <- 0.8
z <- abs(qnorm((1 - confidence) / 2))
e <- 0.1
sigma <- leads_sd
size_population <- nrow(df_leads_complete_filtered)

computed_sample_size_aasc <- (z * sigma / e)^2
computed_sample_size <- ceiling(
  computed_sample_size_aasc *
    (size_population - computed_sample_size_aasc) / (size_population - 1)
)
```

<p style="text-align: center; font-size: 1.4rem;" class="bg-success">
__Ta-dá!__ Para obter uma margem de erro de ``r e`` com ``r confidence*100`%` de confiança, <br/> precisamos de uma amostra de ``r computed_sample_size`` anúncios.
</p>


<div>
<p align="center" width="100%">
![](./images/proud.png){.meme}
</p>
</div>

### Cálculo amostral

#### Tamanho da amostra: n_calculado

```{r}
nivel_conf <- 0.80
z <- qnorm(1 - (1 - nivel_conf) / 2)

n_calculado <- ceiling(z^2 * (var(df_leads_daily_filtered$mean)/0.05^2))
print(paste("n calculado:", n_calculado))
```


#### Margem de erro calculada: margem_erro
```{r}
margem_erro <- z * (sd(df_leads_daily_filtered$mean) / sqrt(n_calculado))
print(paste("margem de erro:", margem_erro))
```


#### Geração de 1000 amostras aleatórias das médias diárias: values_mean_amostral
```{r}
num_amostras <- 1000

set.seed(2024)  # Definida uma semente
values_mean_amostral <- replicate(num_amostras, {
  amostra <- sample(df_leads_daily_filtered$mean, n_calculado, replace = FALSE)
  mean(amostra)
})
print(values_mean_amostral)
```


#### Média amostral das 1000 amostras obtidas: mean_amostral
```{r}
# Média das 1000 amostras geradas de tamanho n_calculado para estimar a média populacional

mean_amostral <- mean(values_mean_amostral)
print(paste("Média amostral:", mean_amostral))
```

#### Cálculo do erro das médias amostrais obtidas: erro
```{r}
# Calculando o maior e o menor valor das médias amostrais
highest_media <- max(values_mean_amostral)
lowest_media <- min(values_mean_amostral)

# Calculando o erro (diferença entre o maior e o menor valor)
erro <- highest_media - lowest_media

# Exibindo os resultados
print(paste("Maior média amostral:", highest_media))
print(paste("Menor média amostral:", lowest_media))
print(paste("Erro (diferença entre maior e menor média):", erro))
```

## Sugestão de tamanho da amostra

Para trabalhos futuros sugerimos que o tamanho da amostra seja de
