---
title: "Tamanho mínimo de amostra"
author: "Arquimedes Macedo. Tiago Rodrigues"
output:
  html_document:
    df_print: paged
    theme: paper
    highlight: tango
    toc: true
    toc_float:
      collapsed: true
    code_folding: hide
  pdf_document:
      toc: true
      latex_engine: pdflatex
      keep_tex: true
      fig_height: 4
      fig_width: 4
header-includes:
  - \usepackage{ifthen}
  - \let\oldincludegraphics\includegraphics
  - \renewcommand{\includegraphics}[2][]{
      \ifthenelse{ \equal{#1}{} }
          { \oldincludegraphics[width=2.5cm,height=2.5cm,keepaspectratio=true]{#2} }
          { \oldincludegraphics[#1]{#2} }
    }
knit: (function(input, encoding) {
    rmarkdown::render(
      input,
      encoding = encoding,
      output_format = 'html_document',
      output_dir = dirname(input),
      output_file = 'index.html'
    );
    rmarkdown::render(
      input,
      encoding = encoding,
      output_format = 'pdf_document'
    );
  })
---

<style>
body {
  font-size: 15px;
}

.table {
  font-size: 12px;
}

.meme {
    display: block;
    max-width: 150px;
    max-height: 150px;
    width: auto;
    height: auto;
}

.bg-danger:not(#dummy) {
  background-color: #f9bdbb;
}
</style>


```{r echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(readxl)
library(knitr)
library(ggplot2)
library(ggridges)
library(reshape2)
library(gridExtra)
library(vtable)
library(purrr)

# Centering figures chunk output
knitr::opts_chunk$set(out.height = "\\textheight",  out.width = "\\textwidth",
                      out.extra = "keepaspectratio=true", fig.align = "center")
```

```{r echo=TRUE}
theme.base <- theme_minimal(base_size = 11) +
  theme(
    axis.text = element_text(size = 8),
    plot.title = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 10),
    panel.grid.major = element_line(colour = "grey90", linewidth = 0.5),
    panel.grid.minor = element_line(colour = adjustcolor("grey90", alpha.f = 0.5), linewidth = 0.25),
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    axis.line.x = element_line(colour = "grey"),
    axis.line.y = element_line(colour = "grey"),
  )

theme.no_legend <- theme(legend.position = "none")

theme.no_grid <-  theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()
)

theme.no_axis <- theme(
  axis.line.x = element_blank(),
  axis.line.y = element_blank()
)

apply.theme.ts <- function() {
  list(
    scale_x_date(date_labels = "%b %d", date_breaks = "1 week"),
    theme.base + theme.no_legend +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()
      )
  )
}

```

## Objetivo

Estimar a quantidade média de leads diários, com 80% de confiança, por anunciante, de anúncios de vendas de imóveis na cidade de Florianópolis (SC).

Com um erro máximo de 0.05, usando Amostragem Aleatório Simples sem Reposição (AASs).

*Lead*: é um contato de um cliente em potencial que demonstrou interesse em um produto ou serviço.

IC de 80% foi escolhido devido à falta de informações (descrita logo mais), e também por ser este o valor máximo recomendado pela ABNT para avaliações de imóveis (NBR 14653).

## Metodologia

Almeja-se, a partir de uma lista de anúncios, realizar uma busca diária de leads, usando uma amostra dos anúncios, e, a partir destes dados, estimar a quantidade média de leads.

No entanto, entende-se que há limitações nas informações disponíveis, como:

-   O número de leads por anúncio.
-   Tempo total que o anúncio ficou ativo.
-   A sazonalidade do mercado (oferta e demanda).
-   A eficácia do anúncio (qualidade do anúncio, preço, localização, etc).
-   A qualidade dos leads (interesse real ou apenas curiosidade).
-   A distribuição subjacente dos leads ao longo do tempo.

Desta forma como um estudo piloto, foram obtidos leads diários, entre Janeiro e Julho de 2024, de anúncios de um anunciante na cidade alvo.

### Análise exploratória

O banco de dados é composto por 3 colunas:

-   `id_registro`: identificador do lead.
-   `data_criado_em`: dia que o lead foi gerado.
-   `id_anuncio`: identificador do anúncio.

#### Amostra dos dados

```{r echo=TRUE}
df_leads <- read_excel("dataset/leads.xlsx", col_types = c("numeric", "date", "text"))
df_leads$data_criado_em <- as.Date(df_leads$data_criado_em)
kable(head(df_leads))
```

#### Leads diários

```{r echo=TRUE}
df_leads %>%
  group_by(data_criado_em) %>%
  summarise(leads = n()) %>%
  ggplot(aes(data_criado_em, leads)) +
  geom_line(color = "royalblue", linewidth = 0.5) +
  labs(title = "Leads diários",
       x = "Dia",
       y = "Leads") +
  apply.theme.ts()

```

Notam-se picos em intervalos semi-regulares, o que pode indicar sazonalidade ou eventos específicos. Além disso, em Julho, houve uma alta variabilidade nos leads diários.

#### Leads por anúncio

Vamos analisar a média diária de leads por anúncio.

Para isso, dividimos o número total de leads pelo número de anúncios únicos para cada dia.

```{r class.source="bg-danger"}
df_leads_incorrect_mean <- df_leads %>%
  group_by(data_criado_em) %>%
  summarise(mean = n()/length(unique(id_anuncio)))

grid.arrange(
  df_leads_incorrect_mean %>%
    ggplot(aes(data_criado_em, mean)) +
    geom_line(color = "royalblue", linewidth = 0.5) +
    labs(title = "Média de leads por dia",
         x = "Dia",
         y = "Média de leads") +
    apply.theme.ts(),
  df_leads_incorrect_mean %>%
    ggplot(aes(mean)) +
    geom_histogram(bins = 30, color = "royalblue", fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "Média de leads",
         y = "") +
    theme.base + theme.no_legend,
  nrow = 2
)
```

<div>

<p style="text-align: center; font-size: 15px; font-weight: bold;">
Será que é só isso mesmo?
</p>

<p align="center" width="100%">
![](./images/flork-pensando.jpg){.meme}
</p>

</div>

Claro que não! A média diária de leads por anúncio é uma estimativa incorreta, pois não considera a quantidade de anúncios ativos em cada dia, e acaba gerando um viés.

### Estimativa da média

Para corrigir o problema anterior, vamos completar os dados com zeros para os dias sem leads.

Isto é, vamos pegar o primeiro e o último dia que o anúncio teve leads, e criar novos registros entre estas datas, para dias sem lead.

```{r}
df_leads_complete <- df_leads %>%
  group_by(id_anuncio, data_criado_em) %>%
  summarise(leads = n(), .groups = 'drop') %>%
  group_by(id_anuncio) %>%
  # Creates a list of dataframes by id
  tidyr::nest() %>%
  mutate(
    # Creates a sequence of dates by id
    date_seq = map(data, ~seq(min(.$data_criado_em), max(.$data_criado_em), by = "day")),
    # Completes the missing dates
    data = map2(
      data, date_seq,
      \(data_, seq_) {
        data_ %>%
          complete(data_criado_em = seq_, fill = list(leads = 0))
      }
    )
  ) %>%
  # Removes the auxiliary column
  select(-date_seq) %>%
  # Unnests the data
  unnest(data)

kable(head(df_leads_complete))
```

A partir desta correção, temos as seguintes médias diárias.

```{r}
df_leads_daily <- df_leads_complete %>%
  group_by(data_criado_em) %>%
  summarise(mean = mean(leads),
            total_leads = sum(leads),
            active_listings = n_distinct(id_anuncio))

grid.arrange(
  df_leads_daily %>%
    ggplot(aes(data_criado_em, mean)) +
    geom_line(color = "royalblue", linewidth = 0.5) +
    labs(title = "Média de leads por dia",
         x = "Dia",
         y = "Média de leads") +
    apply.theme.ts(),
  df_leads_daily %>%
    ggplot(aes(mean)) +
    geom_histogram(bins = 20, color = "royalblue", fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "Média de leads",
         y = "") +
    theme.base + theme.no_legend,
  nrow = 2
)
```

<div>

<p style="text-align: center; font-size: 15px; font-weight: bold;">
Mas não está totalmente correto...
</p>

<p align="center" width="100%">
![](./images/flork-exercer-a-calma.jpg){.meme}
</p>

</div>

Lembrando que esta é uma aproximação e não corresponde totalmente ao que de fato aconteceu, para computar a verdadeira média, precisariamos da listagem de todos os anúncios ativos no dia.

Nota-se, também, que existem pontos extremos no início e no fim da série, isso pode ser explicado por anúncios que estavam ativos antes do início do período analisado ou que apareceram um pouco antes do fim.

Portanto vamos analisar apenas entre 01/02/2024 e 20/07/2024.


```{r}
df_leads_complete_filtered <- df_leads_complete %>%
  filter(between(data_criado_em, as.Date("2024-02-01"), as.Date("2024-07-20")))

df_leads_daily_filtered <- df_leads_complete_filtered %>%
  group_by(data_criado_em) %>%
  summarise(mean = mean(leads),
            total_leads = sum(leads),
            active_listings = n_distinct(id_anuncio))
```


```{r}
sumtable(df_leads_complete_filtered, add.median = T, title = "Registros corrigidos")
```


```{r}
grid.arrange(
  df_leads_daily_filtered %>%
    ggplot(aes(data_criado_em, mean)) +
    geom_line(color = "royalblue", linewidth = 0.5) +
    labs(title = "Média de leads por dia",
         x = "Dia",
         y = "Média de leads") +
    apply.theme.ts(),
  df_leads_daily_filtered %>%
    ggplot(aes(mean)) +
    coord_cartesian(xlim = c(-0.01, 0.4)) +
    geom_histogram(bins = 20, color = adjustcolor("royalblue", alpha.f = 0.3), fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "",
         y = "") +
    theme.base + theme.no_legend + theme.no_axis +
    theme(panel.grid.minor.y = element_blank()),
  df_leads_daily_filtered %>%
    ggplot(aes(mean)) +
    coord_cartesian(xlim = c(-0.02, 0.4)) +
    geom_boxplot(color = adjustcolor("royalblue", alpha.f = 0.8), fill = "royalblue", alpha = 0.5) +
    labs(title = "",
         x = "",
         y = "") +
    theme.base + theme.no_legend + theme.no_axis +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank()),
  nrow = 3,
  heights = c(3, 2, 1.5)
)
```

```{r}
leads_daily_mean <- mean(df_leads_complete_filtered$leads)
leads_daily_sd <- sd(df_leads_complete_filtered$leads)

leads_mean_of_means <- mean(df_leads_daily_filtered$mean)
leads_sd_of_means <- sd(df_leads_daily_filtered$mean)
mean_active_listings <- ceiling(mean(df_leads_daily_filtered$active_listings))

sumtable(df_leads_daily_filtered, add.median = T, title = "Média de leads por dia")
```


## Resultados

Assim, apesar dos pesares, temos uma média de `~`r round(leads_daily_mean, 3)`` leads por dia, com um desvio padrão de `~`r round(leads_daily_sd, 3)``. Além disso, a média das médias diárias é de `~`r round(leads_mean_of_means, 3)`` com um desvio padrão de `~`r round(leads_sd_of_means, 3)``.

### Tamanho da amostra

Calculamos que o tamanho da amostra, a partir da equação

$$
\begin{aligned}
n' &\ge \left(Z_{\alpha / 2} \frac{\sigma}{\text{e}}\right)^2 \\
n  &= n' \cdot \frac{N-n}{N-1}
\end{aligned}
$$

onde,
$Z_{\alpha / 2}$ é o valor crítico da distribuição normal,
$\text{e}$ é a margem de erro,
$\sigma$ é o desvio padrão,
$N$ é o tamanho da população,
$n'$ é o tamanho da amostra com amostra aleatória simples com reposição (AASc), e,
$n$ é o tamanho da amostra sem reposição (AASs).

```{r}
confidence <- 0.8
z <- abs(qnorm((1 - confidence) / 2))
e <- 0.05
sigma <- leads_sd_of_means
size_population <- mean_active_listings

computed_sample_size_aasc <- (z * sigma / e)^2
computed_sample_size <- ceiling(
  computed_sample_size_aasc *
    (size_population - computed_sample_size_aasc) / (size_population - 1)
)
```

Lembrando que queremos estimar a média de leads diários, portanto, vamos usar a média das médias diárias.

<p style="text-align: center;" class="bg-success">
__Ta-dá!__ Para obter uma margem de erro de ``r e`` com ``r confidence*100`%` de confiança, utilizando AASs, <br/> precisamos de uma amostra de ``r computed_sample_size`` anúncios.
</p>


<div>
<p align="center" width="100%">
![](./images/flork-orgulhoso.png){.meme}
</p>
</div>

### Análise do erro

Vamos analisar o erro da média de leads diários, a partir do tamanho da amostra calculado.

```{r}
set.seed(42)

sample_size <- computed_sample_size

# get 20 samples for each day in `df_leads_complete_filtered`
# then get the min, max, and mean of each day
df_leads_daily_sampled <- df_leads_complete_filtered %>%
  group_by(data_criado_em) %>%
  do({
    sample_data <- sample_n(., sample_size, replace = F)
    sample_data %>%
      summarise(min = min(leads),
                max = max(leads),
                mean = mean(leads))
  })

sumtable(df_leads_daily_sampled, add.median = T, title = "Média de leads por dia (amostra)")
```


## Sugestão de tamanho da amostra

Para trabalhos futuros sugerimos que o tamanho da amostra seja de
